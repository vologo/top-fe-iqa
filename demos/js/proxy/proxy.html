<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Proxy</title>
  </head>
  <body>
    <script>
      // Proxy 一个Proxy 对象包装另一个对象并拦截诸如读取写入等其他的操作,简言之，拦截对象的操作
      let user = {
        name: "zs",
        age: 18,
      };
      /**
       * 参数一 target 要包装的对象（可以是函数）
       * 参数二 代理配置 拦截操作方法
       */

      let proxy = new Proxy(user, {});
      console.log(proxy);
      proxy.test = 2;
      console.log(user.test);
      for (let k in user) {
        console.log(k); // name age test
      }
      // 如上的proxy相当于一个透明的 包装器可以设置可以读取并没有设置什么“陷阱”
      // get 陷阱的默认值 也就是读取
      let nums = [1, 2, 3];
      nums = new Proxy(nums, {
        /**
         * 参数一 target
         * 参数二
         */

        get(target, prop) {
          console.log(target); // [1,2,3]
          console.log(prop); // 1
          if (prop in target) {
            return target[prop];
          } else {
            return 0;
          }
        },
      });
      console.log(nums[1]);
      // 上述是一个数组的形式，也可以是一个对象
      let admin = {
        name: "root",
      };
      admin = new Proxy(admin, {
        get(target, prop) {
          console.log(target); // { name:'root'}
          console.log(prop); // name
        },
      });

      console.log(admin["name"]);
      // 接下来我们来看下 set 的陷阱

      let arr = [];
      arr = new Proxy(arr, {
        /**
         * 参数一 target目标对象
         * 参数二 prop目标属性名称
         * 参数三 val 目标属性的值
         * 参数四
         */
        set(target, prop, val) {
          if (typeof val === "number") {
            target[prop] = val;
            return true;
          } else {
            console.log(`set的不是数字number 类型`);
            return false;
          }
        },
      });
      arr.push('1') // Uncaught TypeError: 'set' on proxy: trap returned falsish for property '0'
    </script>
  </body>
</html>
