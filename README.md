## :blue_book: 目录

### HTML

<details>
<summary>查看目录</summary>

- `HTML` 语义化

- meta 有哪些属性，作用是什么

- viewport 有哪些参数，作用是什么

- canvas

- img 中 alt 和 title 的区别

- 说说 HTML5 在标签、属性、存储、API 上的新特性

- doctype 的作用是什么？

- href 和 src 有什么区别

</details>

### CSS

<details>
<summary>查看目录</summary>

- `Link` 与 `@import` 导入`css`的区别
- 伪类和伪元素的区别 css3 新增的伪类有哪些
- 是否了解盒模型 介绍一下标准的 CSS 盒子模型 与低版本的 IE 盒子模型有什么不同
- 你知道什么是 `BFC` 吗 BFC 的布局规则是什么？如何创建 BFC？
- 居中布局：居中浮动元素 居中绝对定位的 DIV
- 浮动元素和绝对定位元素的区别和应用?
- 请说说`css`的选择器以及选择器优先级
- 什么时候清除浮动 如何清除浮动 原理是什么
- CSS 动画
- css 单位有哪些
- 如果需要手动写动画，你认为最小时间间隔是多久，为什么
- 上下 margin 重合的问题
- opacity: 0、visibility: hidden、display: none （隐藏页面中 的元素有哪些 方式）
- display 有哪些值，以及作用
- position 的值
- \*\*png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？
- 如何实现左侧宽度固定，右侧宽度自适应的布局
- 介绍一下 flex
- z-index 有什么需要注意的地方
- position 跟 display、overflow、float 这些特性相互叠加后会怎么样？
- css3 的新特性有哪些
- calc 函数
- CSS 中的 `vertical-align` 有哪些值？它在什么情况下才能生效？
- ::after 和:after 的区别
- CSS 有哪些样式可以给子元素继承!
- 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？
- `box-sizing`常用的属性有哪些? 分别有啥作用?
- CSS 中`transition`和`animate`有何区别? `animate` 如何停留在最后一帧!
- css 创建一个三角形的原理
- “品”字布局如何设计
- 使用过 css 预处理器吗
- 在网页中的应该使用奇数还是偶数的字体？为什么呢
- 什么是响应式 什么是自适应
- 你对 line-height 是如何理解的？
- 如何设计一个 4 列等宽布局，各列之间的边距是 10px（考虑浏览器的兼容性）？
- CSS 如何实现三列布局，左侧和右侧固定宽度，中间自适应宽度？

</details>

### DOM

<details>
<summary>查看目录</summary>

- 事件类型
- 说说`DOM` 中的事件流
- Node 节点获取及增删查改
- 讲讲事件冒泡和事件捕获
- 什么是事件代理
- 知道什么是事件委托吗

</details>

### JavaScript

<details>
<summary>查看目录</summary>

- var、let 和 const 区别的实现原理是什么
- `JavaScript` 的数据类型,存储有什么区别
- 为什么 0.1 + 0.2 != 0.3 ?
- 如何让 (a == 1 && a == 2 && a == 3) 的值为 true？
- es6 的新特性都有哪些？
- ==和===区别是什么？
- typeof 和 instance of 检测数据类型有什么区别？
- prototype 和 `__proto__` 区别是什么？
- `null`和`undefined`有什么区别么
- for of , for in 和 forEach,map 的区别
- 如何判断两个变量相等
- 谈谈你对原型的理解？
- 什么是原型链？【原型链解决的是什么问题？】
- 说说你对执行上下文的理解
- 什么是变量提升
- 立即执行函数
- [↓ 谈谈作用域与作用域链的理解](#谈谈作用域与作用域链的理解如何理解)
- 闭包及作用闭包有哪些使用场景？优缺点是很什么
- 对象的拷贝：深拷贝与浅拷贝
- new 运算符 new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别
- 箭头函数
- instanceof 实现的原理是什么 内部机制是怎样的
- ES5/ES6 的继承 分别有哪些优缺点？
- 类型的转化
- 防抖与节流，它们的作用是什么
- this 如何正确的判断 this 的指向? 箭头函数的 this 是什么？
- `sort` 函数
- 函数科里化
- 如何提升 JavaScript 变量的存储性能？
- ['1', '2', '3'].map(parseInt)
- [[3,2,1].reduce(Math.pow), [].reduce(Math.pow)]
- Set、Map、WeakSet 和 WeakMap 的区别
- 判断数组的方法
- JavaScript 中的数组是如何存储的
- 类数组和数组的区别是什么？
- call 与 applycall,aplly 和 bind 的内部是如何实现的？
- 数组的哪些 API 会改变原数组？
- 在 JS 中什么是变量提升？什么是暂时性死区？
- 可迭代对象有哪些特点
- 垃圾回收与内存泄漏

</details>

### jQuery

<details>
<summary>查看目录</summary>

- 手写插件

</details>

### Vue

<details>
<summary>查看目录</summary>

- 什么是 MVVM？谈谈你的理解
- 谈谈你对`vue`生命周期的理解
- 什么是
- 生命周期钩子的作用
- 第一次页面加载触发哪几个生命周期钩子
- 异步请求适合在哪个生命周期调用
- vue 组件中的参数如何传递？如何进行通信
- 说说 Vue 中`$nextTick`的实现原理 它的执行时机是什么时候 和 DOM 的渲染有什么关系
- vue 修饰符
- Vue 中的 key 有什么作用？
- 组件中 data 为什么是一个函数？
- vue 是如何实现数据的双向绑定
- v-show 与 v-if 有什么区别？
- v-model 的原理？
- Class 与 Style 如何动态绑定？
- vue 的`单向数据流`

- `vue` 中组件通信有几种方式
- 数据响应原理
- 虚拟 DOM 原理以及优缺点
- computed watch methods 三者的应用场景与区别以及实现原理
- 对比一下 `Object.defineProperty` 与`proxy`
- 直接给一个数组项赋值，Vue 能检测到变化吗？在 Vue 中怎么检测数组的变化
- 使用 JavaScript Proxy 实现简单的数据绑定
- Vue 是如何实现数据双向绑定的？
- Vue 框架怎么实现对象和数组的监听？
- vue-router 的路由模式有几种
- 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？
- vuex 的设计思想
- 单页面（SPA）应用的优缺点
- 谈谈你对 keep-alive 的了解？vue 里的 keep-alive 是怎么实现的
- 谈谈 Vue SSR 吗？说说 SSR？
- Vue 怎么用 vm.\$set() 解决对象新增属性不能响应的问题 ？
- 你有对 Vue 项目进行哪些优化？可以从几方面入手
- 谈谈`vue 3.0`
- `$route`和`$router`的区别
- scoped 属性作用
- `Vue-Router`的两种模式主要依赖什么实现的
- Vue CLI 有哪些特性？
- 如何新增自定义指令
- vue 的数据劫持在不同的版本里是如何处理的？
- 了解 Element UI 组件的框架设计吗？
- 如何自动屏蔽 Input 的自动密码填充？

</details>

### React

<details>
<summary>查看目录</summary>

- [列表组件中的 key](#列表组件中的`key`)
- setState 到底是异步还是同步?
- 为什么使用框架而不是原生
- 虚拟 DOM 的优劣如何
- 虚拟 DOM 的实现原理
- React 最新的生命周期是怎样的?
- React 的请求应该放在哪个生命周期中?
- Ajax 请求放在 `componentDidMount` 里进行处理还是放在`componentWillMount` 里进行处理比较合适？
- React 中 setState 什么时候是同步的，什么时候是异步的
- react-router 里的 `<Link>` 标签和 `<a>` 标签有什么区别
- react 与`vue` 的区别
- React 高阶组件的作用有哪些
- 简述下 flux 的思想
- redux 的工作流程?
- react-redux 是如何工作的?
- redux 与 mobx 的区别?
- redux 中如何进行异步操作?
- React 组件通信如何实现?
- React 有哪些优化性能是手段? 语法层面呢？
- React 如何进行组件/逻辑复用?
- mixin、hoc、render props、react-hooks 的优劣如何？
- 你是如何理解 fiber 的?
- 有没有使用过 React Hooks？使用 React Hooks 的同时为什么需要使用高阶组件？
- 受控组件以及非受控组件的区别

</details>

### Flutter

<details>
<summary>查看目录</summary>

- [列表组件中的](#列表组件中的`key`)

- React 中 setState 什么时候是同步的，什么时候是异步的

- react-router 里的 `<Link>` 标签和 `<a>` 标签有什么区别

</details>

### TypeScript

<details>
<summary>查看目录</summary>
- 谈你对 TypeScript 的理解？

- 比较一下 TypeScript 和 JavaScript，在什么情况下你觉得需要 TypeScript ?

</details>

### Node

<details>
<summary>查看目录</summary>

- 谈谈 node 中的事件循环 浏览器和 Node.js 的事件循环机制有什么区别？

</details>

### Babel

<details>
<summary>查看目录</summary>

- 谈谈`babel` 的原理是什么

</details>

### 框架

<details>
<summary>查看目录</summary>

- React 和 Vue 的区别？
- 能对比一下 Create React App 和 Vue CLI 吗？
- 了解 MVC / MVP / MVVM 的区别吗？
</details>

### 测试

<details>
<summary>查看目录</summary>

- 平常开发的过程中有写过单元测试或者 e2e 测试么？
- 自动化测试主要是做什么？

</details>

### Webpack

<details>
<summary>查看目录</summary>

- 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的
- 介绍`webpack` 的实现原理
- Webpack 的 loader 和 plugins 的区别
- Webpack 构建速度优化有哪些方案？

</details>

### 浏览器

<details>
<summary>查看目录</summary>

- 输入`URL` 发生了什么
- 常见的浏览器内核
- 常见的兼容性问题
- 重绘与回流
- 本地存储 cookie 与 token
- session、cookie、localStorage 的区别 了解 SameSite 属性吗
- 如何实现浏览器内多个标签页之间的通信?
- JSONP 的原理是什么？

</details>

### 移动端

<details>
<summary>查看目录</summary>

- 触摸事件

- 移动端的兼容问题

- 移动端 300ms 延迟

- 移动端 rem

- 移动端 1px

</details>

###

### 服务端

### 模块化

<details>
<summary>查看目录</summary>

- 模块化发展历史

</details>

### 异步编程

<details>
<summary>查看目录</summary>

- setTimeout、Promise、Async/Await 的区别

- 模拟实现一个 Promise.finally

- Promise 构造函数是同步还是异步执行，then 中的方法呢 ?promise 如何实现 then 处理 ?

- Promise 和 setTimeout 的区别 ?

- 如何实现 Promise.all ?

- EventLoop

- async await 函数

</details>

### 性能优化

<details>
<summary>查看目录</summary>

- 能说说首屏加载优化有哪些方案么
- 首屏和白屏的时间如何计算
- 什么是 GPU 加速，如何使用 GPU 加速，GPU 加速的缺点
- 异步加载 JS 脚本的方式有哪些？
- css 有哪些提高性能的方法
- 在 HTML 中如何做 SEO 优化？
- 了解 CSS 3 动画的硬件加速么？在重绘和重流方面有什么需要注意的点？
- 了解 SPA 的懒加载么？

</details>

### 安全问题

<details>
<summary>查看目录</summary>

- CSRF 攻击
- XSS 漏洞
- CORS（跨域资款共享）
-

</details>

### 计算机网络

<details>
<summary>查看目录</summary>

- http 与 https 协议
- 讲讲 http 的基本结构？
- HTTP2 和 HTTP1 有什么区别
- http 常见的状态码
- `GET` 与`Post` 的区别
- TCP 三次握手四次挥手
- 谈谈你对 TCP 的理解;
- HTTP 的请求报文由哪几部分组成
- HTTP 常见请求/响应头及其含义
- HTTPS 是如何进行加密的 谈谈 https 的原理？为什么 https 能保证安全？
- CDN 原理
- DNS 解析
- websocket 和 ajax 的区别是什么，websocket 的应用场景有哪些
- 讲讲 http 的缓存机制吧，强缓存，协商缓存？

</details>

### 数据结构算法

<details>
<summary>查看目录</summary>

- 排序算法

- 全排列

- 各种排序

- 优先遍历和广度优先遍历

- 冒泡排序如何实现

- 二分查找

</details>

### 设计模式

<details>
<summary>查看目录</summary>

- 常见的设计模式有哪些？
- 计模式中观察者模式和发布 / 订阅模式有哪些区别？

</details>

### 手写代码

<details>
<summary>查看目录</summary>

- [↓ 手写数组去重方法](#1-手写数组去重的方法)

- [↓ 手写`new`操作符](#1-手写数组去重的方法)

- 手写`JSON.stringify`

- 手写`JSON.parse`

- 手写`call`或 `apply`

- 手写继承

- 手写函数柯里化

- 手写`Promise`

- 手写防抖与节流

- 手写深拷贝

- 手写`instanceof`

- 数组扁平化 :请实现一个 flattenDeep 函数，把嵌套的数组扁平化

</details>

### 笔试

<details>
<summary>查看目录</summary>

- 请写出下面代码的运行结果

  ```js
  async function async1() {
    console.log("async1 start");
    await async2();
    console.log("async1 end");
  }
  async function async2() {
    console.log("async2");
  }
  console.log("script start");
  setTimeout(function () {
    console.log("setTimeout");
  }, 0);
  async1();
  new Promise(function (resolve) {
    console.log("promise1");
    resolve();
  }).then(function () {
    console.log("promise2");
  });
  console.log("script end");
  ```

* 计算两个数组的交集
* JS 实现`String.trim()`方法;
* 数组去重
* 简单实现一个发布者订阅机制

</details>

### 软技能

## JavaScript

1. ### 谈谈作用域与作用域链的理解，如何理解?

面试的时候，面试官会问`JS中的作用域是什么` 要知道`作用域是什么` 我们需要先了解几个简单的概念

- 编译原理 执行的过程一般会有三个步骤
  ![](https://user-gold-cdn.xitu.io/2020/6/16/172bd8191abf433b?w=802&h=486&f=png&s=27546)

其次的话是`引擎` 查询变量的两种方式

- 一个是**LHS 查询**
- 一个是**RHS 查询**

也就是说当变量出现在赋值操作的左侧进行 `LHS` ；当出现在右侧时进行`RHS` 一上来就搞这些乱起八遭的英文缩写，啥意思

```javascript
console.log(a);
```

以上的代码就是想得到 `a` 的值，那就是——RHS

```javascript
a = 123;
```

以上的代码给`a` 赋值，那就是——LHS

那么说完查询的方式，跟作用域有什么用？其中从某种方式上来理解**作用域便是查找变量的一套规范化的规则**

那如果我查找的引用无法在当前的作用域内完成怎么办，比如说

```javascript
function foo(a) {
  console.log(a + b); // b取值，想得到b的值，那就是RHS 那么引用的查找在当前的 foo无法完成
}

var b = 123;
foo(456);
```

![](https://user-gold-cdn.xitu.io/2020/6/16/172bd9591dc641b6?w=464&h=411&f=png&s=9736)

整个的一块就像是一栋大楼，然后不停的勇敢的向上走，我们如上提及的那栋大楼便是**词法作用域**

- 一种是词法作用域
- 一种是动态作用域

那我们重点聊的是`词法` ，下面来看一段代码

![](https://user-gold-cdn.xitu.io/2020/6/16/172bda0752c43347?w=728&h=369&f=png&s=20385)

我们还不得不谈 `函数作用域` 以及 `块作用域`

- 生命每个函数都会自身创建一个笑脸

  对于内部的实现我们是可以隐藏的，比如

  ```javascript
  function doSomething(){
    ....balabala
  }
  ```

  谁也不知道函数里干了啥，巴拉巴拉

  当我们这样写的时候

  ```javascript
  (function foo() {
    console.log(`I LOVE MEINV`);
  })();
  ```

  我们社区给这种操作起了个骚气的名字`IIFE` 即为 **立即执行表达式**，在我们实际开发的时候是十分常见的

- 还有就是块作用域

  那么什么情况下会形成块作用域

  - with 用 with 从对象中创建的作用域仅在 with 声明中而非外部
  - try catch

  其中`catch` 分句会创建一个块作用域

  ```javascript
  try {
    console.log(a);
  } catch (error) {
    console.log(error);
  }
  console.log(error); // ReferenceError: error is not defined
  ```

  - let

    为其声明的变量隐式的劫持了所在的块作用域

  - const

    const 同样可以创建一个块级作用域

**[:top: 返回顶部](#blue_book-目录)** **[:top: 返回 JavaScript](#javascript)** **[ :point_right: 你怎么看 ](https://github.com/yayxs/top-fe-iqa/issues/1)**

## Vue

### 1. computed watch methods 三者的应用场景与区别以及实现原理?

#### 首先说`watch监听`

- 使用场景：在某个数据变化的时候做事情
- 使用方法如下

```js
 baseData:'', // 一种是基本的数据类型
 params:{
        arr:[1],

  },
```

```
watch:{
   baseData(val){
     console.log(val)
   },
   params:{
     handler(newVal,oldVal){
       console.log(newVal)
       console.log(oldVal)
     },
    //  deep:true, 深度监听数组对象等数据类型
     immediate: true // 一上来就执行
   }
  },
```

其中注意两个词

- immediate: true 一上来就会执行
- deep 其中 deep 是深度监听 给对象的所有属性都增加监听器 ，但是性能开销大
  - 当用户指定了 watch 中的 deep 属性为 true 时，如果当前监控的值是数组类型。会对对象中的每 一项进行求值，此时会将当前 watcher 存入到对应属性的依赖中，这样数组中对象发生变化时也 会通知数据更新

可以通过

```
  "obj.a": {
      handler(newName, oldName) {
        console.log(newName);
        console.log(oldName);
      },
      immediate: true,
    },
```

#### `其次是计算属性`

**根据依赖的数据进行动态计算，有缓存**

- 应用场景就是 计算一个值比较费劲
- 使用方法简单

**[:top: 返回顶部](#blue_book-目录)** **[:top: 返回 Vue](#vue)** **[ :point_right: 你怎么看 ](https://github.com/yayxs/top-fe-iqa/issues/1)**

#### `最后是方法`

## 2.

## 异步编程

大家都在说`promise` ，面试的时候也基本是必问的问题，一般知识点的话，一些网上的参考文章是不会过时的，比如像一些配置性的文章大家可能喜欢看最近的文章。我们将从**基本概念** **原理** **面试** 去看这些问题。首先要说的就是`promise` .一般我们就是读文档，从简单到难。

> Promise 是个对象

```js
Promise instanceof Object;
true;
```

> 代表一个异步操作的最终完成或者失败

假设现在我们需要这样一件事情：**创建一个音频文件，这就需要我们准备两个回调函数，一是成功的时候调用，二是失败的时候调用**

![image-20200610213825567](https://raw.githubusercontent.com/yayxs/Pics/master/image-20200610213825567.png)

那这样我们就需要准备两个回调函数，有了`promise` 之后，我们就可以这样

```js
const promise = createAudioFileAsync(audioSettings);
promise.then(successCallback, failureCallback);
```

> promise A+ 规范

关于`promise` 一般会从三个角度出发

- 直接是概念
- 给一段代码输出

## 手写代码

### 1. 手写数组去重的方法

```javascript
/**
 * 谈到数组去重，几乎是面试必备的一道开胃菜
 * 要想数组去重，第一件事就是有一个数组
 */
// 首先第一步
console.log(1 === 1); // true
console.log("1" === "1"); // true
console.log("true" === "true"); // true
console.log(false === false); // true
console.log(undefined === undefined); // true
console.log(null === null); // true

console.log(NaN === NaN); // false
console.log({} === {}); // false
console.log([] === []); // false
// 接着第二步：准备含有重复元素的目标数组
let needDeduplicatedArr = ["1", "1", 1, 1, true, true, null, null]; // 需要去重的数组元素
let arr = ["1", "1", 1, 1];
// 第三步：写去重方法
// ------------------使用哈希表-------------------------------------------------------------------
const unique1 = (target) => {
  let result = []; // 结果数组
  let hash = {};
  for (let ele of target) {
    if (!hash[ele]) {
      // hash 中没有数组中的元素
      result.push(ele); // 把元素放进去
      hash[ele] = true; // hash中已经存在了标记为true 下次循环就不会接着往结果数组中放相同的元素了
    }
  }
  return result;
};

const unique10 = (target) => {
  let map = new Map(); // 初始化 map
  let result = new Array(); // 初始化 数组
  for (let i = 0; i < target.length; i++) {
    if (map.has(target[i])) {
      map.set(target[i], true);
    } else {
      map.set(target[i], false);
      result.push(target[i]);
    }
  }
  return result;
};

// 缺点 hash中存在相同的 key 就不往下找了， 但 '1' 和 1 是不同的元素
// ------------------数组遍历-------------------------------------------------------------------
const unique2 = (target) => {
  let result = [];
  for (let i = 0; i < target.length; i++) {
    if (result.indexOf(target[i]) === -1) {
      // 在结果数组中没有找到元素
      result.push(target[i]);
    }
  }
  return result;
};

// ------------------数组遍历-------------------------------------------------------------------
const unique3 = (target) => {
  let result = [];
  for (let ele of target) {
    // 其中 ele 是每一目标元素中每一元素
    !result.includes(ele) && result.push(ele); // 如果结果数组中没有ele就添加进去
  }
  return result;
};

// ------------------先给数组排序-------------------------------------------------------------------
const unique4 = (target) => {
  target.sort();
  console.log(target);
  let result = [target[0]];
  for (let i = 1; i < target.length; i++) {
    target[i] !== target[i - 1] && result.push(target[i]); // 当前项和它的前一项不同的时候，才添加进结果数组
  }
  return result;
};

// ------------------双层for循环-------------------------------------------------------------------
const unique5 = (target) => {
  //   let result = [];

  for (let i = 0; i < target.length; i++) {
    for (let j = i + 1; j < target.length; j++) {
      if (target[i] === target[j]) {
        // 如果两项元素相同的话，则从目标元素中删除一个
        target.splice(j, 1);
        // splice 会改变原数组，所以相关的长度都要减去一
        i--;
        j--;
      }
    }
  }

  return target;
};

// ------------------set结构-------------------------------------------------------------------
const unique6 = (target) => {
  // Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。
  let x = new Set(target); // Set { '1', 1, true, null }

  return [...x]; // 转为数组
};
const unique7 = (target) => {
  // Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。
  let x = new Set(target); // Set { '1', 1, true, null }

  return Array.from(x); // 转为数组
};
// ------------------Array.filter()-------------------------------------------------------------------
const unique8 = (target) => {
  return target.filter((item, index) => {
    return target.indexOf(item) === index; // 数组的下标与检索的下标一致
  });
};

// ------------------reduce+includes-------------------------------------------------------------------
const unique9 = (target) => {
  return target.reduce((previousValue, currentValue, currentIndex) => {
    return previousValue.includes(currentValue)
      ? previousValue
      : [...previousValue, currentValue];
  }, []);
};
const res = unique10(needDeduplicatedArr);
console.log(res);
// ------------------obj.hasOwnProperty()-------------------------------------------------------------------
const unique11 = (target) => {
  let obj = {}; // 初始化一个空的对象
  let result = new Array();
  result = target.filter((item, index) =>
    obj.hasOwnProperty(item) ? false : (obj[item] = true)
  );
  return result;
};
```

**[:top: 返回手写代码](#手写代码)** **[ :point_right: 你怎么看 ](https://github.com/yayxs/top-fe-iqa/issues/3)**

### 2. 手写 JavaScript `New`

> JavaScript 中的 new 操作符

#### 面试题

根据`new操作符`相关的知识点一般会 延伸出以下的**面试题** ，面试官你是否有很多问号

- 问题一：new 之后都做了些什么？？
- 问题二：能否手写 new 操作符原理？？

[mdn 关于 new 运算符关键字的描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)

> 1.  创建一个空的简单 JavaScript 对象（即`{}`）；
> 2.  链接该对象（即设置该对象的构造函数）到另一个对象 ；
> 3.  将步骤 1 新创建的对象作为`this`的上下文 ；
> 4.  如果该函数没有返回对象，则返回`this`。

以上 4 条是`MDN` 上关于 new 操作符（或者说关键字）的面试，简单的来体验下利用构造函数来`new` 一个对象

```js
var self;

function Person(name) {
  console.log(this);
  self = this;
  this.name = name;
}
let p = new Person("张三");
console.log(p);
console.log(self === p); // true 构造函数中的this 绑定在了p这个对象上
console.log(p.__proto__ === Person.prototype); // 对象p的原型属性指向构造函数的原型，这样也就保证了实例能够访问在构造函数原型中定义的属性和方法。
```

然后在**构造函数添加原型方法**

```js
function Persion(name) {
  this.name = name;
}
console.log(Persion.prototype);
Persion.prototype.sayHello = function () {
  console.log(this); // 指向构造出的对象
  console.log(this.name); // 小明
};

let xiaoMing = new Persion("小明");
xiaoMing.sayHello();
```

经过上文的简单案例我们可以得知，

- `new` 一个构造函数得到一个对象，它的原型属性（也就是** proto **）与该构造函数的原型是全等

- `new` 通过构造函数 `Persion` 创建出来的实例可以访问到构造函数中的属性,就行这样

  ```js
  console.log(xiaoMing.name); // 小明
  ```

- 言简意赅：new 出来的实例对象通过原型链和构造函数联系起来

**构造函数说白了也是一个函数，那是函数就可以有返回值**

```js
function Person(name) {
  this.name = name;
  //   return 1; // 返回内部新创建的对象
  //   return "1"; // 返回内部新创建的对象
  // return null; // 返回内部新创建的对象
  //   return undefined; // 返回内部新创建的对象
  //   return {}; // {} // 直接返回
  return function () {}; // 直接返回
  return [1]; // [1] // 直接返回
}
let p = new Person("李四");
console.log(p);
```

有了给构造函数返回一个值得想法，那就通过不同的`数据类型` 进行测试得出结论

- 不同的数据类型返回的效果是不一样的，像数字 1 字符串”1“ ，返回的依然是内部创建的对象
- **那如果返回一个对象（{}）或者说数组（【】）** 都会直接返回回去

#### 小结

也就是说，构造函数一般不需要`return`

- 返回一般的数据类型吧，不起作用
- 返回对象吧， new 的意义又何在呢

#### 手写一个自己的 myNew

如果自己实现一个 new 的话，首先要满足它的几点效果

1. 一个构造函数会返回一个对象，那函数里就应该有对象

   ```js
   let obj = {};
   ```

2. 并将其`__proto__`属性指向构造函数的`prototype`属性

   ```js
   obj.__proto__ = constructor.prototype;
   ```

3. 调用构造函数，绑定 this

   ```js
   constructor.apply(obj, args);
   ```

4. 返回原始值需要忽略，返回对象需要正常处理

   ```js
   res instanceof Object ? res : obj;
   ```

#### 测试成果

```
function myNew() {
  let [constructor, ...args] = [...arguments];
  let obj = {};
  obj.__proto__ = constructor.prototype;

  let res = constructor.apply(obj, args);
  return res instanceof Object ? res : obj;
}

function Person(name) {
  this.name = name;
//   return {};
}

Person.prototype.sayHi = function () {
  console.log(`原型方法中的函数--${this.name}`);
};
let p1 = myNew(Person, "测试");
// console.log(p1)
p1.sayHi();
console.log(p1.name);
```

### 箭头函数使用`new`

```js
var Foo = () => {};
var foo = new Foo(); // TypeError: Foo is not a constructor
```

- 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误

**`this`指向的固定化，并不是因为箭头函数内部有绑定`this`的机制，实际原因是箭头函数根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`。正是因为它没有`this`，所以也就不能用作构造函数。**

## :love_letter: 公众号

<div align="center">
    <img width="360px" height="160px" src="https://github.com/yayxs/top-fe-iqa/blob/master/assets/images/%E5%85%AC%E4%BC%97%E5%8F%B7.png"></img>
</div>
